<!DOCTYPE html><html style="display:none"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><script>window.materialVersion="0.1.1",window.oldVersion=["0.1.0"]</script><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="renderer" content="webkit"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>Spring Boot 简介 | 且听书吟</title><link rel="icon shortcut" type="image/ico" href="https://cat.yufan.me/asserts/spectre/images/favicon.png"><link rel="icon" href="https://cat.yufan.me/asserts/spectre/images/favicon.png"><meta name="format-detection" content="telephone=no"><meta name="description" itemprop="description" content="第一次使用 Springboot 应该是15年年底，当时就被这种约定大于配置的设计惊呆了。那个时候才从上一家公司跳槽，用的是 Spring  3。所以每次开发新项目的时候，配置起来都让我十分痛苦，也因此喜欢上了 Springboot 的种种便利。
众观 Springboot 的发展，可以发现，其在简化开发上不断地进步。很多常见的组件框架也有了 Springboot 版本。我想，作为 Java 程序员，是时候进入 Springboot 的世界了。"><meta name="keywords" content="雨帆, 且听书吟,学习"><meta name="theme-color" content="#455A64"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}},lsloader.removeLS=function(e){try{localStorage.removeItem(e)}catch(e){}},lsloader.setLS=function(e,s){try{localStorage.setItem(e,s)}catch(e){}},lsloader.getLS=function(e){var s="";try{s=localStorage.getItem(e)}catch(e){s=""}return s},versionString="/*"+(window.materialVersion||"unknownVersion")+"*/",lsloader.clean=function(){var e,s;try{for(e=[],s=0;s<localStorage.length;s++)e.push(localStorage.key(s));e.forEach(function(e){var t=lsloader.getLS(e);window.oldVersion&&window.oldVersion.reduce(function(e,s){return e||-1!==t.indexOf("/*"+s+"*/")},!1)&&lsloader.removeLS(e)})}catch(e){}},lsloader.clean(),lsloader.load=function(e,s,t,n){var o;if("boolean"==typeof t&&(n=t,t=void 0),n=n||!1,t=t||function(){},(o=this.getLS(e))&&-1===o.indexOf(versionString))return this.removeLS(e),void this.requestResource(e,s,t,n);if(o){if(o.split(versionString)[0]!=s)return console.log("reload:"+s),this.removeLS(e),void this.requestResource(e,s,t,n);o=o.split(versionString)[1],n?(this.jsRunSequence.push({name:e,code:o}),this.runjs(s,e,o)):(document.getElementById(e).appendChild(document.createTextNode(o)),t())}else this.requestResource(e,s,t,n)},lsloader.requestResource=function(s,t,e,n){var o=this;n?this.iojs(t,s,function(e,s,t){o.setLS(s,e+versionString+t),o.runjs(e,s,t)}):this.iocss(t,s,function(e){document.getElementById(s).appendChild(document.createTextNode(e)),o.setLS(s,t+versionString+e)},e)},lsloader.iojs=function(s,t,e){var n,o=this;o.jsRunSequence.push({name:t,code:""});try{(n=new XMLHttpRequest).open("get",s,!0),n.onreadystatechange=function(){if(4==n.readyState){if((200<=n.status&&n.status<300||304==n.status)&&""!=n.response)return void e(s,t,n.response);o.jsfallback(s,t)}},n.send(null)}catch(e){o.jsfallback(s,t)}},lsloader.iocss=function(s,t,e,n){var o,a=this;try{(o=new XMLHttpRequest).open("get",s,!0),o.onreadystatechange=function(){if(4==o.readyState){if((200<=o.status&&o.status<300||304==o.status)&&""!=o.response)return e(o.response),void n();a.cssfallback(s,t,n)}},o.send(null)}catch(e){a.cssfallback(s,t,n)}},lsloader.iofonts=function(s,t,e,n){var o,a=this;try{(o=new XMLHttpRequest).open("get",s,!0),o.onreadystatechange=function(){if(4==o.readyState){if((200<=o.status&&o.status<300||304==o.status)&&""!=o.response)return e(o.response),void n();a.cssfallback(s,t,n)}},o.send(null)}catch(e){a.cssfallback(s,t,n)}},lsloader.runjs=function(e,s,t){var n,o,a;if(s&&t)for(n in this.jsRunSequence)this.jsRunSequence[n].name==s&&(this.jsRunSequence[n].code=t);this.jsRunSequence[0]&&this.jsRunSequence[0].code&&"failed"!=this.jsRunSequence[0].status?((o=document.createElement("script")).appendChild(document.createTextNode(this.jsRunSequence[0].code)),o.type="text/javascript",document.getElementsByTagName("head")[0].appendChild(o),this.jsRunSequence.shift(),0<this.jsRunSequence.length&&this.runjs()):this.jsRunSequence[0]&&"failed"==this.jsRunSequence[0].status&&(a=this,(o=document.createElement("script")).src=this.jsRunSequence[0].path,o.type="text/javascript",this.jsRunSequence[0].status="loading",o.onload=function(){a.jsRunSequence.shift(),0<a.jsRunSequence.length&&a.runjs()},document.body.appendChild(o))},lsloader.tagLoad=function(e,s){this.jsRunSequence.push({name:s,code:"",path:e,status:"failed"}),this.runjs()},lsloader.jsfallback=function(e,s){if(!this.jsnamemap[s]){for(var t in this.jsnamemap[s]=s,this.jsRunSequence)this.jsRunSequence[t].name==s&&(this.jsRunSequence[t].code="",this.jsRunSequence[t].status="failed",this.jsRunSequence[t].path=e);this.runjs()}},lsloader.cssfallback=function(e,s,t){var n,o;this.cssnamemap[s]||(this.cssnamemap[s]=1,(n=document.createElement("link")).type="text/css",n.href=e,n.rel="stylesheet",n.onload=n.onerror=t,(o=document.getElementsByTagName("script")[0]).parentNode.insertBefore(n,o))},lsloader.runInlineScript=function(e,s){var t=document.getElementById(s).innerText;this.jsRunSequence.push({name:e,code:t}),this.runjs()},lsloader.css=function(e,s){void 0===window.lsLoadCSSMaxNums&&(window.lsLoadCSSMaxNums=0),window.lsLoadCSSMaxNums++,lsloader.load(e,s,function(){void 0===window.lsLoadCSSNums&&(window.lsLoadCSSNums=0),window.lsLoadCSSNums++,window.lsLoadCSSNums==window.lsLoadCSSMaxNums&&(document.documentElement.style.display="")},!1)},lsloader.js=function(e,s){lsloader.load(e,s,!0)}</script><script>function Queue(){this.dataStore=[],this.offer=function(e){this.debug&&console.log("Offered a Queued Function.");"function"==typeof e?this.dataStore.push(e):console.log("You must offer a function.")},this.poll=function(){this.debug&&console.log("Polled a Queued Function.");return this.dataStore.shift()},this.execNext=function(){var e=this.poll();void 0!==e&&(this.debug&&console.log("Run a Queued Function."),e())},this.debug=!1,this.startDebug=function(){this.debug=!0}}var queue=new Queue</script><style id="spectre_css"></style><script>lsloader.css("spectre_css","https://cat.yufan.me/asserts/spectre/styles/spectre/spectre.min.css")</script><style id="spectre_exp_css"></style><script>lsloader.css("spectre_exp_css","https://cat.yufan.me/asserts/spectre/styles/spectre/spectre-exp.min.css")</script><style id="style_css"></style><script>lsloader.css("spectre_exp_css","https://cat.yufan.me/asserts/spectre/styles/style.min.css")</script><style id="prism_css"></style><script>lsloader.css("prism_css","https://cat.yufan.me/asserts/spectre/styles/prism.min.css")</script><link rel="alternate" type="application/rss+xml" href="/rss.xml"><meta property="og:title" content="Spring Boot 简介 | 且听书吟"><meta property="og:type" content="blog"><meta property="og:url" content="https://yufan.me/springboot-brief-intro/"><meta property="og:image" content="https://cat.yufan.me/asserts/spectre/images/favicon.png"><meta property="og:description" content="第一次使用 Springboot 应该是15年年底，当时就被这种约定大于配置的设计惊呆了。那个时候才从上一家公司跳槽，用的是 Spring  3。所以每次开发新项目的时候，配置起来都让我十分痛苦，也因此喜欢上了 Springboot 的种种便利。
众观 Springboot 的发展，可以发现，其在简化开发上不断地进步。很多常见的组件框架也有了 Springboot 版本。我想，作为 Java 程序员，是时候进入 Springboot 的世界了。"><meta property="og:article:tag" content="学习"><meta property="article:published_time" content="Sat May 13 2017 20:52:00 GMT+0000"><meta property="article:modified_time" content="Sat Dec 22 2018 14:13:49 GMT+0000"><meta name="twitter:card" content="summary"><meta property="twitter:site" content="https://twitter.com/syhily"><meta property="twitter:creator" content="syhily"><script type="text/javascript">!function(){var e=document.createElement("script");e.src="//tajs.qq.com/stats?sId=11315873";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="canonical" href="https://yufan.me/springboot-brief-intro/"><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://yufan.me"
    },
    "headline": "Spring Boot 简介",
    
    "datePublished": "2017-05-13T20:52:00.000Z",
    "dateModified": "2018-12-22T14:13:49.311Z",
    "author": {
        "@type": "Person",
        "name": "雨帆",
        "image": {
            "@type": "ImageObject",
            "url": "https://cat.yufan.me/asserts/spectre/images/avatar.jpg"
        },
        "description": "我思 我说 我写"
    },
    "publisher": {
        "@type": "Organization",
        "name": "且听书吟",
        "logo": {
            "@type": "ImageObject",
            "url": "https://cat.yufan.me/asserts/spectre/images/favicon.png"
        }
    },
    "keywords": ",学习雨帆, 且听书吟",
    "description": "第一次使用 Springboot 应该是15年年底，当时就被这种约定大于配置的设计惊呆了。那个时候才从上一家公司跳槽，用的是 Spring  3。所以每次开发新项目的时候，配置起来都让我十分痛苦，也因此喜欢上了 Springboot 的种种便利。
众观 Springboot 的发展，可以发现，其在简化开发上不断地进步。很多常见的组件框架也有了 Springboot 版本。我想，作为 Java 程序员，是时候进入 Springboot 的世界了。"
}</script><link rel="stylesheet" href="/css/prism-solarizedlight.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div class="off-canvas off-canvas-sidebar-show"><a class="off-canvas-toggle btn btn-link btn-action" href="#sidebar"><i class="icon material-icons casino-icons">menu</i></a><div id="sidebar" class="off-canvas-sidebar"><div id="sidebar-content"><ul class="nav"><a class="off-canvas-toggle btn btn-link btn-action" href="#close"><i class="icon material-icons casino-icons">arrow_back</i></a><div class="sidebar-top"></div><span class="h4 text-center">且听书吟</span><div class="divider"></div><li class="nav-item"><a href="/"><i class="icon material-icons sidebar-icons">home</i> 主页</a></li><li class="nav-item"><a href="/archives/"><i class="icon material-icons sidebar-icons">inbox</i> 归档</a></li><li class="nav-item"><a href="/tags"><i class="icon material-icons sidebar-icons">bookmark</i> 标签</a></li><li class="nav-item"><a href="/about"><i class="icon material-icons sidebar-icons">person</i> 关于</a></li><li class="nav-item"><a href="/gallery"><i class="icon material-icons sidebar-icons">photo</i> 映像</a></li><li class="nav-item"><a href="/links"><i class="icon material-icons sidebar-icons">people</i> 友链</a></li><div class="divider"></div><li class="nav-item"><a href="/archives/" style="display:flex">文章总数<div style="flex-grow:1;padding-left:1rem!important"></div><span class="sidebar-badge">174</span></a></li></ul></div></div><a class="off-canvas-overlay" href="#close"></a><div class="off-canvas-content"><main><div class="container container-post"><div class="card post-card col-mx-auto"><div class="card-image" style="background-image:url(https://cat.yufan.me/cats/2017-05-13-26782367_p0.jpg)"></div><div class="card-header"><div class="card-header-title"><div class="card-title h4">Spring Boot 简介</div></div><div class="divider"></div><div><ul class="post-categories-list"><li class="post-categories-list-item"><a class="post-categories-list-link" href="/categories/学习/">学习</a></li></ul><ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/学习/">学习</a></li></ul></div></div><br><div id="post-content" class="card-body"><p>第一次使用 Springboot 应该是 15 年年底，当时就被这种约定大于配置的设计惊呆了。那个时候才从上一家公司跳槽，用的是 Spring 3。所以每次开发新项目的时候，配置起来都让我十分痛苦，也因此喜欢上了 Springboot 的种种便利。</p><p>众观 Springboot 的发展，可以发现，其在简化开发上不断地进步。很多常见的组件框架也有了 Springboot 版本。我想，作为 Java 程序员，是时候进入 Springboot 的世界了。</p><a id="more"></a><p>这里分享一份一年前，我在公司内部分享上用的 Slide，以期对于阅读此文的你有所帮助。</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0001.jpg" alt=""></p><p>大家好，今天由我来向大家简单介绍一下 Spring Boot 相关的内容，详细的与 Spring Boot 相关的知识将后面由吴一敏同学分享。</p><p>首先自我介绍一下，我叫盛宇帆，15 年年底加入 OneAPM，现在已经 1 年多了，目前主要负责和告警引擎相关的开发。</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0002.jpg" alt=""></p><p>Spring 官方的博客介绍 Spring： <strong>Spring</strong> is the <strong>“glue”</strong> in your application。我认为 Spring Boot 就是 A glue in Spring Framework。</p><p>相信大家都经历过配置 Spring XML 的阶段，十分痛苦地去配置一个 Bean，后面 Spring 3 发布之后，基本上很多配置都是通过注解加扫包去配置初始化。<br>我常见到的一种配置方式，就是和 Spring 框架集成部分的配置，如数据库啊，Web 模板一类的，使用的是 XML，自己项目的 Service、Dao 等类，使用注解初始化。<br>后面 Spring 4 开始流行 @Configuation 注解的配置类初始化配置。</p><p>然而，这样子还是十分麻烦，所以才有了 Spring Boot，它给我们最直观的感受，就是 简化了配置。一言一概之，约定大于配置。</p><p>然而，仅有这些，并不能说明为何现在 Spring Boot 开始流行，说道 Spring Boot 的兴起，我想起前几天一个技术群的提问：为什么 Spring Boot 应用倾向于打 fat jar 直接启动，而传统的应用倾向于打 war 包从应用容器启动？</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0003.jpg" alt=""></p><p>Java 应用部署于应用容器中，其实是受到 J2EE 的影响，也算是 Java Web 有别于其他 Web 快速开发语言的一大特色。一个大大的 war 压缩包，包含了全部的依赖，代码，静态资源，模板。</p><p>在虚拟化流行之前，应用都是部署在物理机上的，为了节约成本，多 war 包部署在一个 Servlet 容器内。</p><p>但是为了部署方便，如使用的框架有漏洞、项目 jar 包的升级，我们会以解压 war 包的方式去部署。或者是打一个不包含依赖的空 war 包，指定容器的加载某个目录，这样所有的 war 项目公用一套公共依赖，减少内存。当然缺点很明显，容易造成容器污染。</p><p>避免容器污染，多 war 部署变为多虚拟机单 war、单容器。</p><p>DevOps 流行，应用和容器不再分离，embedded servlet containers 开始流行 Spring Boot 在这个阶段应运而生。于是项目部署变为 fat jar + 虚拟机</p><p>Docker 的流行，开始推行不可变基础设施思想，实例（包括服务器、容器等各种软硬件）一旦创建之后便成为一种只读状态，不可对其进行任何更改。如果需要修改或升级某些实例，唯一的方式就是创建一批新的实例以替换。</p><p>基于此，我们将配置文件外置剥离，由专门的配置中心下发配置文件。</p><p>这也是我们为何要学习和使用 Spring Boot 的背景，我觉得这才是 Spring Boot 开始流行的主要原因。</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0004.jpg" alt=""></p><p>总的来说 Spring Boot 有以下几个特点。</p><ol><li>配置简化，这个我印象最深刻的就是写 MyBatis 的时候，一堆东西要配置，一般大家都会用那个 Generator 去生成。而实际上 Spring Boot 推崇 jpa，如果只是简单的 CRUD，用 Spring Boot + JPA 的方式简单到只需要几行关于数据库的配置就好了。</li><li>自动配置机制，很多教程都称它为 Magic，基于项目的某些条件，自动初始化装配必要的 Bean，稍后会在后面的演示中详解。</li><li>Starter 本质上就是 Spring 基于 Gradle 和 Maven 这两种构建工具定义的一组依赖，一般是按照功能或者框架划分。在有了自动配置的机制下，我们只需要依赖 Starter 指定的坐标，和非常简单的属性配置即可集成我们想要的框架。</li><li>嵌入的 Servlet 容器，主要是为了方便部署的。</li><li>主要是 <code>spring-boot-starter-actuator</code> 和 <code>spring-boot-starter-remote-shell</code> 的使用，当然，这里还可以使用 JMX 一类的做管理，大家可以参考文档。（2017 年更新 remote shell 已经废弃）</li></ol><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0005.jpg" alt=""></p><p>首先，我们来用 Spring Boot 写一个 Hello World 吧，这个是仿照 Spring 官方的示例代码改的，使用 Groovy，所以连 import 都省了。这里主要是为了演示一个最简单的 Spring Boot 应用，通过下面的这行命令我们就能把它启动了。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span>
<span class="token keyword">class</span> <span class="token class-name">GreetingRestController</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/hi/{name}"</span><span class="token punctuation">)</span>
    def <span class="token function">hi</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">[</span> greeting<span class="token operator">:</span> <span class="token string">"Hello, "</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0006.jpg" alt=""></p><p>现在，问题来了，刚才那个项目那么简单，那个，整个项目的启动过程中，到底发生了哪些魔法呢？</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0007.jpg" alt=""></p><p>我们将 Groovy 的代码翻译为 Java 版本，大概会看到，一个项目想要启用 Spring Boot，关键在于 <code>SpringApplication</code> 类和 <code>EnableAutoConfiguration</code> 注解的使用。</p><p>SpringApplication 是 Spring Boot 提供的用于 Java main 方法的启动类。它的执行操作首先为：</p><ol><li>Create an appropriate {@link ApplicationContext} instance (depending on your classpath)</li><li>Register a {@link CommandLinePropertySource} to expose command line arguments as Spring properties</li><li>Refresh the application context, loading all singleton beans Trigger any {@link CommandLineRunner} beans</li></ol><p>然后 <code>EnableAutoConfiguration</code> 则为 Enable 类注解这里通过此注解，告诉 Spring Boot 开启自动装配的特性。</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0008.jpg" alt=""></p><p>除了 <code>EnableAutoConfiguration</code>，我们常常和它并列使用的还有 <code>ComponentScan</code> <code>Configuration</code> 注解。这三个注解合起来，有一个等价的注解，叫做 <code>SpringBootApplication</code>，一般在我们的项目开发中，喜欢在项目最外面的包下面创建包含 main 方法的程序启动类，然后这个类上标记为 @SpringBootApplication 这个注解，这样就等价于基于 main 方法类所在的 package 为 Spring 扫包的基础包路径，且开启自动化配置。</p><p>自动化配置的实现，不得不说 Spring Boot 本质上是通过 Conditional 类注解来实现的。</p><p><code>@ConditionalOnClass</code> 表示对应的类在 classpath 目录下存在时，才会去执行注解所标示的自动配置类或者自动配置方法，与之对应的我们就 @ConditionalOnMissingClass 注解，也就是找不到对应的类的时候。</p><p><code>@ConditionalOnBean</code> 和 <code>@ConditionalOnMissingBean</code> 则同样很容易按照字面意思理解。</p><p>当然 <code>Conditional*</code> 注解不仅仅上面提到的这些，还有 <code>ConditionalOnExpression</code> 一类的。</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0009.jpg" alt=""></p><p>这个是我们从 Spring Boot 当中节选的一段代码，主要是为了演示自动化配置的具体实现。首先我们在项目配置里面标明 spring.jmx.enabled = true，ConditionalOnProperty 注解生效，然后 Spring 发现能找到 <code>MBeanExporter.class</code> 这个类，于是开始执行自动化配置的方法，因为这个时候项目中没有定义 <code>MBeanExporter</code> 这个 Bean，于是 <code>ConditionalOnMissingBean</code> 注解生效，Spring 开始读取配置属性，自动创建此 Bean 对象。</p><p>同理，任何一个自动装配的实现，基本上就是组合这些条件注解。</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0010.jpg" alt=""></p><p>当然，如果能被 Spring Boot 官方直接支持的话是最吼的，目前被支持的肯定不止上面这些，我只是简单地列举了一些常见的项目。</p><p>Spring Boot 官方之前发起过好几次投票，就是列举一些框架，然后大家投票选择哪些想要被官方支持的。上半年的时候，我还在里面看到了之前姜老师维护的 camel，然而似乎并没有被选中。MyBatis 目前虽然有 Spring Boot 版，但是是由 MyBatis 团队自行维护，至少我 6 月份尝试使用的时候，问题还是蛮多的。 (2017 年之后的版本基本可用，主要是有了 Boot 版本的 VFS)</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0011.jpg" alt=""></p><p>上面是我从 Spring Boot 1.3.6 中找到的 spring.factories 文件的截图。当然，基本上只要上面有的，都能得到不错的支持。</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0012.jpg" alt=""></p><p>前面我们简单介绍了自动配置的实现原理，基本上流程就是配置文件标明启用什么服务，然后找到对应的依赖（class），然后结合条件装配初始化 Bean。</p><p>所以 Spring 就更进一步，按照功能模块，划分出一个个 Starter 模块。以 Maven 为例，基本上我们只需要将 Spring Boot 自己的那个 POM 文件设置为 parent，然后依赖中直接依赖所需的 Starter 坐标，即可依赖所有所需的 jar 包，剩下的的东西，仅有最基础的属性值配置。</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0013.jpg" alt=""></p><p>当然 Starter 也是一把双刃剑，比如我在项目里面依赖了 <code>spring-boot-starter-data-jpa</code> 之后在 IDEA 里面看到的依赖树，简直就是 jar 包狂魔，虽然我们需要 jpa，但是不一定需要全部这些包。</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0014.jpg" alt=""></p><p>这也就引出了我使用 Starter 的时候的几个困扰。比如项目需要以 spring-boot 的 pom 为 parent，这个就比较讨厌了，尤其是我前公司，所有的项目是同一内部的 parent，这样子可以管理大家的依赖。如果要用 Spring Boot 的话，就会略有麻烦。可能就需要通过依赖 Spring Boot 的 pom 的方式，并不是很优雅。</p><p>问题二是我在用 Spring Boot 时依赖 logstash 遇到的， logstash 自己依赖了一个 logback-access 和那个版本的 Spring Boot 依赖的 logback 不一致，导致一直报一个 <code>java.lang.AssertionError</code></p><p>问题三就是我最近想用 Spring Boot 去读写 Kafka，结果我们用的 Kafka 版本比较老，最后只好自己配置，特别麻烦。很多老的组件，要么你得用老的 Spring Boot，要么你就得自己配置。</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0015.jpg" alt=""></p><p>比如我们基于 YAML 定义了上图这么一段配置，最简单的方式就是 <code>@Value</code> 注解，通知这货还支持 Spring El 表达式，做一些简单的处理判断。</p><p>但是对于一个组件的配置，或者是项目自己的配置，更需要比较好的梳理，Spring Boot 便支持了所谓的 prefix 前缀的概念，我们可以把所需要的配置信息定义为一个配置类，在里面定义好必要的 Getter Setter 一类的东西。在初始化项目的时候使用 <code>@EnableConfigurationProperties</code> 注解即可实现配置参数注入到配置类里面。</p><p>当然麻烦的地方在于如果配置文件定义的层级过深，配置类会变得极其复杂。建议这种情况下，尽可能简化层级。</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0016.jpg" alt=""></p><p>配置文件的加载，其实 Spring Boot 有一个非常复杂的流程，大家好奇的话可以看 Spring Boot 文档中的定义，大概有十几种情况。但是大部分情况下，我们用不了这么多，上面是我认为应该知道并且利用的几种情况，配置加载的顺序是由上往下。</p><p>第一种情况，和 jar 包在同一目录下，一般是应用发布到生产，然后还想修改更新配置的情况。</p><p>项目 resources 目录和 resources/config 下面的配置文件，就是我们在开发的时候会选取的存放配置的位置。</p><p>当然配置文件的名称默认是 application，还可能根据你所启用的 Profile 加载不同名称的配置文件。</p><p>由于配置文件的指定在 Spring Boot 中极其灵活，（官方可能把所有的情况都考虑到了）所以大家可以自己按需选择。</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0017.jpg" alt=""></p><p>测试当然也有 Starter，我们只需要依赖 <code>spring-boot-starter-test</code>，即可轻松写测试。常见的测试注解就是上面几个</p><p><code>@WebIntegrationTest</code> 注解相当于 <code>@IntegrationTest</code> + <code>@WebAppConfiguration</code> 注解结合使用，在 1.3 之前，主要是使用前面 4 个注解进行测试。</p><p>1.4 之后，我们主要使用 <code>SpringBootTest</code> 注解做测试</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0018.jpg" alt=""></p><p>最老的方式，你可能会使用 <code>@ContextConfiguration</code> 注释和 <code>SpringApplicationContextLoader</code> 的组合去写单元测试。</p><p>当然，我们可以去掉 loader 的配置，使用方法 2 的 <code>SpringApplicationConfiguration</code> 注解去测试</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0019.jpg" alt=""></p><p>当想写一个集成测试的时候，可以使用 <code>IntegrationTest</code> 注解，和前面的不一样的是，前面两种方式不会初始化全部的 Bean，而 <code>IntegrationTest</code> 会和生产环境一样，完整初始化程序。但是它不会初始化 嵌入式的 Servlet 容器。</p><p>当你需要嵌入式的 Servlet 容器做一些接口的集成测试的时候，就需要使用 <code>WebIntegrationTest</code> 注解</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0020.jpg" alt=""></p><p>然而一个项目，基本上包含 <code>SpringApplication</code> 和 main 方法的类只有一个，所以在 1.4 之后，我们连 App.class 都不需要给定，直接使用 <code>@SpringBootTest</code> 注解即可，更加优雅。</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0021.jpg" alt=""></p><p>这个就是我基于 Spring Boot 1.3 写的一个集成测试，当然它使用的是我们前面说的方法 3。</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0022.jpg" alt=""></p><p>前面我们其实已经说到了 Spring Boot 的 <code>Profile</code> 可以让我们区分不同环境下加载的配置文件。比如开发环境，测试和线上，很多值都可以实现定制，而不需要重新打包项目。</p><p>使用 Profile 的第二个场景就是不同的 Profile 需要初始化不同的 bean，比如以 DataSource 为例，测试的时候，因为测试环境不一样，我们更期望 DataSource 能用 H2 一类的嵌入式数据库模拟。开发和生产环境，就需要初始化一个 MySQL 的 DataSource。当然我说的这个场景不需要我们专门去配置，因为 Spring Boot 已经替我们考虑到了这种情况，在需要 DataSource，但是没有这个 Bean，切依赖了 H2 的 Driver 的时候，Spring 会自动创建一个 H2 的 DataSource。</p><p>还有一个我使用 Profile 的场景就是 Swagger，它十分好用，尤其是开发的时候能基于注解自动生成 API Doc，和测试页面，然而，会存在的问题就是它有漏洞，我只希望在开发的时候启用 Swagger，这个时候就可以利用 Profile 来实现。</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0023.jpg" alt=""></p><p>Profile 可以启用一个或者多个，然而，也会导致一些问题，比如我们没有指定 Profile 的时候怎么办，或者我们有 profile 名为 mysql、cassadra。它们是相互 block 的，如何检查校验，避免冲突的 profile 同时启用呢？</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0024.jpg" alt=""></p><p>这个是添加默认 Profile 的方式，原来我是尝试在 application 配置文件里面设置，但是不生效，最后我只好手动编码实现。</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0025.jpg" alt=""></p><p>这个方法是和 main 方法同级的一个方法，需要 Autowired Spring 的 Environment 接口，然后获取 Profile 的配置，即可自行实现判断逻辑。（期待后面 Profile 能更加完善，实现 Block 一类的属性）</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0026.jpg" alt=""></p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0027.jpg" alt=""></p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0028.jpg" alt=""></p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0029.jpg" alt=""></p><p>Spring Boot 官方推崇的部署方式是 jar，原因我们前面也分析过了，但是也会存在打包为 war 去部署的需求。这里我们只需要在和 Application.class 同级的路径下继承 SpringBootServletInitializer 类去定义一下 SpringApplicationBuilder 的配置即可，还是很轻松的。我这个截图的示例里面用了前面设置默认 Profile 的方法，重用了一下代码。</p><p>有了这么一个类之后，我们就可以在 pom 里面设置项目打包为 war，它既能 java –jar 去执行这个 war，也能直接丢到 Tomcat 一类的容器里面运行。</p><p>我们在 17 年的实践中发现，很多时候，非 Fatjar 也有一定的意义，于是有了下属的打包启动实践，大家可以去参考。</p><p><a href="https://gist.github.com/syhily/c66310c150653e8f92b9fa6693df8207" rel="external nofollow noopener noreferrer" target="_blank">https://gist.github.com/syhily/c66310c150653e8f92b9fa6693df8207</a></p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0030.jpg" alt=""></p><p>如果想要快速创建一个 Spring Boot 项目开发，有且不仅有上述几种方式。</p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0031.jpg" alt=""></p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0032.jpg" alt=""></p><p><img src="https://cat.yufan.me/slide/spring-boot-intro/0033.jpg" alt=""></p><p>你可以点击 <a href="https://cat.yufan.me/work/springboot-intro.pptx" rel="external nofollow noopener noreferrer" target="_blank">这里 </a>下载到本地浏览。</p></div><div class="post-footer-info bg-gray"><figure class="avatar centered"><img src="https://cat.yufan.me/asserts/spectre/images/avatar.jpg"></figure><section class="post-footer-date"><p class="card-subtitle text-gray mb-0">Publish: 2017-05-13<br>Update: 2018-12-22</p></section><section class="post-footer-action"><div class="dropdown dropdown-right float-right"><a class="btn btn-link btn-gray dropdown-toggle" tabindex="0"><i class="icon material-icons casino-icons">share</i></a><ul class="menu"><li class="menu-item"><a href="https://twitter.com/intent/tweet?text=Spring Boot 简介&url=https://yufan.me/springboot-brief-intro/index.html&via=雨帆" target="_blank" rel="external nofollow noopener noreferrer">分享到 Twitter</a></li><li class="menu-item"><a href="https://www.facebook.com/sharer/sharer.php?u=https://yufan.me/springboot-brief-intro/index.html" target="_blank" rel="external nofollow noopener noreferrer">分享到 Facebook</a></li><li class="menu-item"><a href="https://plus.google.com/share?url=https://yufan.me/springboot-brief-intro/index.html" target="_blank" rel="external nofollow noopener noreferrer">分享到 Google+</a></li><li class="menu-item"><a href="https://telegram.me/share/url?url=https://yufan.me&text=且听书吟" target="_blank" rel="external nofollow noopener noreferrer">分享到 Telegram</a></li></ul></div><div class="dropdown dropdown-right float-right"><a class="btn btn-link btn-gray dropdown-toggle" tabindex="0"><i class="icon material-icons casino-icons">devices_other</i></a><ul class="menu"><li class="menu-item"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACY0lEQVR42u3aQW7DQAgF0Nz/0u0BolgfmBk70fOqclyLNwuDgNffT18vPDw8PDw8PDy8h/Fe8RW9+u35/J3V//34Hjw8PLwjvCTo60NJ7l9j3p9sxoaHh4d3kJcEl3zck4SRYJoHh4eHh/clvOoRJEeDh4eH90u8pOT99OZq4Y6Hh4f3ZF4v0HnxfV2IH+214OHh4cW8fMh0/u+j8z08PDy8gFdeaYrL696dxUtXeHh4eBt4kwWpJMH02hbVePDw8PBO8q5bDPuaudUjS6LCw8PDO8ObDMCSVYBeu7YaAx4eHt69vLxovk4GkxXV65QwSgx4eHh4Y17+0qTpUB3zz8HlZgQeHh7eIl5etlZTQrWMzu+UVwfw8PDwFvF6DYjqKkAy4kqGXtHB4eHh4W3mJZ/70TiquGRQLfHx8PDw7uIlo6wkuDwx9FJFlJzw8PDwNvOqIeZh9ZJBr62Mh4eHdxcv/yhXi+neulWvsMbDw8PbzasO+3uJpLqAtbiNi4eHh7eUlwdXHZjlK1mrUhEeHh7eSV6+NJD8mqSB3vOL27h4eHh4A17+UZ4U09XPfZ6W8PDw8O7lVVNCFTNfQSgPwPDw8PA286qlcN54raafalMDDw8P7wyveuVt3GoyyJcMCokBDw8PbwOvN6TPG6yTQjxvUuDh4eGd581H+0kLYxT02qUrPDw8vEW86kJVPs6vlsuTFIWHh4f3ZN7uNm7eOMbDw8P7Ll7z8z1IBgvme3h4eHiLeHmJ3Btc5WkgP3o8PDy8u3jVgjgpjvNG8GQMhoeHh3ee93sXHh4eHh4eHh7eA65/w/nOStQaWsoAAAAASUVORK5CYII="></li></ul></div></section></div><div class="divider m-0"></div><div class="post-nav px-2 bg-gray"><ul class="pagination"><li class="page-item page-prev"><a href="/atelier-firis-first-year-walk-through/"><div class="page-item-title h5"><i class="icon material-icons casino-icons">arrow_back</i></div><div class="page-item-subtitle">《菲莉丝的工作室》一年期主线任务流程攻略</div></a></li><li class="page-item page-next"><a href="/rewrite-your-logic/"><div class="page-item-title h5"><i class="icon material-icons casino-icons">arrow_forward</i></div><div class="page-item-subtitle">在编程中思考，简化你的判断逻辑</div></a></li></ul></div><div class="card-footer"><div id="disqus_thread"></div><style></style><div class="btn_click_load"><button class="btn btn-primary disqus_click_btn">阅读评论（请确保 disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config=function(){this.page.url="https://yufan.me/springboot-brief-intro/",this.page.identifier="https://yufan.me/springboot-brief-intro/"}</script><script type="text/javascript">var xhr=new XMLHttpRequest;xhr.open("GET","https://disqus.com/next/config.json",!0),xhr.timeout=4e3,xhr.send(),xhr.onload=function(){if(200==this.status||304==this.status){var t=document,e=t.createElement("script");e.src="//xiaoyu-1.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e),document.querySelector(".disqus_click_btn").setAttribute("style","display:none")}},xhr.ontimeout=function(t){document.querySelector(".disqus_click_btn").setAttribute("style","display:block")},xhr.onerror=function(t){document.querySelector(".disqus_click_btn").setAttribute("style","display:block")},document.querySelector(".disqus_click_btn").onclick=function(){var t,e;t=document,(e=t.createElement("script")).src="//xiaoyu-1.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e),document.querySelector(".disqus_click_btn").setAttribute("style","display:none")}</script></div></div></div></main><footer class="centered"><div class="footer-content"><div class="footer-sns-list"><a href="https://twitter.com/syhily" target="_blank" rel="external nofollow noopener noreferrer"><button class="footer-sns-btn footer-sns-twitter"></button></a><a href="https://www.facebook.com/syhily" target="_blank" rel="external nofollow noopener noreferrer"><button class="footer-sns-btn footer-sns-facebook"></button></a><a href="https://github.com/syhily" target="_blank" rel="external nofollow noopener noreferrer"><button class="footer-sns-btn footer-sns-github"></button></a><a href="https://t.me/syhily" target="_blank" rel="external nofollow noopener noreferrer"><button class="footer-sns-btn footer-sns-telegram"></button></a></div><div class="footer-copyright"><div>Copyright&nbsp;©&nbsp;<span year=""></span> <a href="https://yufan.me">且听书吟</a></div><div><a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">闽ICP备12017112号-1</a></div></div><div class="footer-develop"><div>Powered by <a href="https://hexo.io" rel="external nofollow noopener noreferrer" target="_blank" class="footer-develop-a">Hexo</a></div><div>Theme - <a href="https://github.com/neoFelhz/hexo-theme-spectre" target="_blank" class="footer-develop-a" rel="external nofollow noopener noreferrer">Spectre</a></div></div></div></footer><div class="back-to-top rounded"><a href="#"><i class="icon material-icons casino-icons">expand_less</i></a></div></div></div><script>lsloader.js("lazy_js_vender","https://cat.yufan.me/asserts/spectre/scripts/lazyload.min.js")</script><script type="text/javascript">var myLazyLoad=new LazyLoad({elements_selector:".lazy"});window.onload=function(){setInterval(function(){queue.execNext()},200)}</script><script type="text/javascript">var copyrightNow=(new Date).getFullYear(),textContent=document.querySelector("span[year]");copyrightSince=2011,copyrightSince===copyrightNow?textContent.textContent=copyrightNow:textContent.textContent=copyrightSince+" - "+copyrightNow</script></body></html>